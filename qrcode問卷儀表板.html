<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¡ƒåœ’å¸‚å…¬è»Šqrcodeå•å·åˆ†æç³»çµ±</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }
        
        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            animation: fadeInDown 0.8s ease;
        }
        
        .header p {
            color: #666;
            font-size: 1.1em;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            animation: fadeInUp 0.8s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
        }
        
        .stat-card h3 {
            font-size: 0.9em;
            margin-bottom: 10px;
            opacity: 0.9;
        }
        
        .stat-card .value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-card .label {
            font-size: 0.85em;
            opacity: 0.8;
        }
        
        .charts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            animation: fadeIn 1s ease;
        }
        
        .chart-container h2 {
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .controls {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        
        .controls h2 {
            color: #333;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group label {
            color: #666;
            font-weight: bold;
        }
        
        .control-group select,
        .control-group input {
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
            min-width: 150px;
        }
        
        .control-group input[type="date"] {
            min-width: 160px;
        }
        
        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .data-table {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }
        
        .data-table h2 {
            color: #333;
            margin-bottom: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }
        
        tr:hover {
            background: #f5f5f5;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
        }
        
        .file-upload {
            margin-bottom: 30px;
            padding: 30px;
            border: 3px dashed #667eea;
            border-radius: 15px;
            text-align: center;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .file-upload label {
            display: inline-block;
            padding: 15px 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        .file-upload label:hover {
            transform: scale(1.05);
        }
        
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .satisfaction-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .satisfaction-good {
            background: #4caf50;
            color: white;
        }
        
        .satisfaction-medium {
            background: #ff9800;
            color: white;
        }
        
        .satisfaction-bad {
            background: #f44336;
            color: white;
        }
        
        /* PDF åŒ¯å‡ºå„ªåŒ–ï¼šé¿å…åˆ‡é–‹åœ–è¡¨ã€è®“è³‡æ–™è¡¨æ›é  */
        .chart-container {
            break-inside: avoid;
            page-break-inside: avoid;
        }
        .data-table {
            break-before: page;
            page-break-before: always;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸšŒ æ¡ƒåœ’å¸‚å…¬è»Šä¹˜å®¢æ»¿æ„åº¦åˆ†æç³»çµ±</h1>
            <p>å³æ™‚æŒæ¡ä¹˜å®¢å›é¥‹ï¼Œå„ªåŒ–å…¬è»Šæœå‹™å“è³ª</p>
        </div>
        
        <div class="file-upload">
            <input type="file" id="fileInput" accept=".xlsx,.xls">
            <label for="fileInput">ğŸ“ ä¸Šå‚³Excelæª”æ¡ˆ</label>
            <p style="margin-top: 15px; color: #666;">è«‹ä¸Šå‚³æ¡ƒåœ’å¸‚å…¬è»Šæ»¿æ„åº¦èª¿æŸ¥Excelæª”æ¡ˆ</p>
        </div>
        
        <div id="content" style="display: none;">
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>ç¸½å•å·æ•¸</h3>
                    <div class="value" id="totalResponses">0</div>
                    <div class="label">ä»½æœ‰æ•ˆå•å·</div>
                </div>
                <div class="stat-card">
                    <h3>å¹³å‡æ»¿æ„åº¦</h3>
                    <div class="value" id="avgSatisfaction">0%</div>
                    <div class="label">æ•´é«”è©•åƒ¹</div>
                </div>
                <div class="stat-card">
                    <h3>APPä½¿ç”¨ç‡</h3>
                    <div class="value" id="appUsageRate">0%</div>
                    <div class="label">æ•¸ä½åŒ–ç¨‹åº¦</div>
                </div>
                <div class="stat-card">
                    <h3>æ¯æ—¥æ­ä¹˜ç‡</h3>
                    <div class="value" id="dailyRidership">0%</div>
                    <div class="label">é«˜é »ä½¿ç”¨è€…</div>
                </div>
            </div>
            
            <div class="controls">
                <h2>ğŸ“Š è³‡æ–™ç¯©é¸èˆ‡åˆ†æ</h2>
                <div class="control-group">
                    <label>è·¯ç·šç¯©é¸ï¼š</label>
                    <select id="routeFilter">
                        <option value="all">æ‰€æœ‰è·¯ç·š</option>
                    </select>
                    
                    <label>æ—¥æœŸç¯„åœï¼š</label>
                    <input type="date" id="startDate" title="é–‹å§‹æ—¥æœŸ">
                    <span style="margin: 0 10px;">è‡³</span>
                    <input type="date" id="endDate" title="çµæŸæ—¥æœŸ">
                    
                    <label>æ™‚æ®µç¯©é¸ï¼š</label>
                    <select id="timeFilter">
                        <option value="all">å…¨éƒ¨æ™‚æ®µ</option>
                        <option value="morning">ä¸Šåˆ (06:00-12:00)</option>
                        <option value="afternoon">ä¸‹åˆ (12:00-18:00)</option>
                        <option value="evening">æ™šä¸Š (18:00-24:00)</option>
                    </select>
                    
                    <label>è³‡æ–™ç­†æ•¸ï¼š</label>
                    <select id="rowsPerPage" title="æ¯é é¡¯ç¤ºç­†æ•¸">
                        <option value="10">10</option>
                        <option value="25">25</option>
                        <option value="50" selected>50</option>
                        <option value="100">100</option>
                        <option value="all">å…¨éƒ¨</option>
                    </select>
                    
                    <button class="btn" onclick="updateCharts()">æ›´æ–°åœ–è¡¨</button>
                    <button class="btn" onclick="exportReport()">åŒ¯å‡ºå ±å‘Š</button>
                </div>
            </div>
            
            <div class="charts-section">
                <div class="chart-container">
                    <h2>ğŸ“ˆ æ•´é«”æ»¿æ„åº¦åˆ†å¸ƒ</h2>
                    <canvas id="satisfactionChart"></canvas>
                </div>
                <div class="chart-container">
                    <h2>ğŸ• å¡«å¯«æ™‚æ©Ÿåˆ†æ</h2>
                    <canvas id="timingChart"></canvas>
                </div>
                <div class="chart-container">
                    <h2>ğŸ¯ æ­ä¹˜ç›®çš„çµ±è¨ˆ</h2>
                    <canvas id="purposeChart"></canvas>
                </div>
                <div class="chart-container">
                    <h2>ğŸ“± å„é …æ»¿æ„åº¦æ¯”è¼ƒ</h2>
                    <canvas id="detailedSatisfactionChart"></canvas>
                </div>
            </div>
            
            <div class="data-table">
                <h2>ğŸ“‹ è©³ç´°è³‡æ–™è¡¨</h2>
                <div id="tableToolbar" style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; gap:10px; flex-wrap:wrap;">
                    <div id="tableInfo" style="color:#555;">é¡¯ç¤º 0â€“0 / å…± 0 ç­†</div>
                    <div style="display:flex; gap:8px;">
                        <button id="prevPage" class="btn" style="padding:8px 16px;">ä¸Šä¸€é </button>
                        <button id="nextPage" class="btn" style="padding:8px 16px;">ä¸‹ä¸€é </button>
                    </div>
                </div>
                <div style="overflow-x: auto;">
                    <table id="dataTable">
                        <thead>
                            <tr>
                                <th>å¡«å¯«æ™‚æ©Ÿ</th>
                                <th>ç«™ä½åç¨±</th>
                                <th>è·¯ç·š</th>
                                <th>æ•´é«”æ»¿æ„åº¦</th>
                                <th>æ­ä¹˜é »ç‡</th>
                                <th>æ­ä¹˜ç›®çš„</th>
                                <th>å»ºè­°äº‹é …</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div id="loading" class="loading" style="display: none;">
            <h2>â³ æ­£åœ¨è¼‰å…¥è³‡æ–™...</h2>
        </div>
    </div>
    
    <script>
        let rawData = [];
        let charts = {};
        let currentPage = 1;
        
        // åœ¨DOMè¼‰å…¥å®Œæˆå¾Œç¶å®šäº‹ä»¶
        // å•Ÿç”¨ Chart.js è³‡æ–™æ¨™ç±¤å¤–æ›ï¼Œä¸¦è¨­å®šå…¨åŸŸé è¨­æ¨£å¼ï¼ˆç¾è§€ï¼šå°æ¯”è‰²ã€åœ“è§’è† å›Šåº•ã€é™°å½±ï¼‰
        if (window.Chart && window.ChartDataLabels) {
            // === Datalabel helpers for contrast-aware styling ===
            const parseColor = (c) => {
                if (!c) return null;
                if (Array.isArray(c)) return c; // dataset can be array per item
                return c;
            };
            const hexToRgb = (hex) => {
                if (!hex) return null;
                let h = hex.replace('#', '').trim();
                if (h.length === 3) h = h.split('').map(ch => ch + ch).join('');
                if (h.length !== 6) return null;
                const num = parseInt(h, 16);
                return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
            };
            const cssToRgb = (css) => {
                if (!css) return null;
                // rgb(a) or hex
                if (css.startsWith('#')) return hexToRgb(css);
                const m = css.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
                if (!m) return null;
                return { r: +m[1], g: +m[2], b: +m[3] };
            };
            const luminance = ({ r, g, b }) => {
                const srgb = [r, g, b].map(v => {
                    v /= 255;
                    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
                });
                return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
            };
            const getContrastText = (bgColor) => {
                const rgb = cssToRgb(bgColor);
                if (!rgb) return '#111';
                const L = luminance(rgb);
                return L > 0.5 ? '#111' : '#fff';
            };
            const getDatasetBgAt = (ctx) => {
                const ds = ctx.dataset;
                const idx = ctx.dataIndex ?? 0;
                const bg = parseColor(ds && ds.backgroundColor);
                if (!bg) return null;
                return Array.isArray(bg) ? bg[idx % bg.length] : bg;
            };

            Chart.register(window.ChartDataLabels);
            Chart.defaults.plugins.datalabels = {
                // è‰²å½©ï¼šä¾åœ–è¡¨èˆ‡åº•è‰²è‡ªå‹•å°æ¯”
                color: (ctx) => {
                    const type = ctx.chart.config.type;
                    if (type === 'bar') return '#fff';
                    const bg = getDatasetBgAt(ctx);
                    // è‹¥ä½¿ç”¨ç™½è‰²è† å›Šåº•ï¼Œå…§æ–‡å­—ç”¨æ·±è‰²
                    return (type === 'pie' || type === 'doughnut') ? '#111' : (getContrastText(bg) || '#333');
                },
                backgroundColor: (ctx) => {
                    const type = ctx.chart.config.type;
                    if (type === 'bar') return 'rgba(51, 65, 85, 0.85)'; // slate-700 ~ æ·±è‰²è† å›Š
                    if (type === 'pie' || type === 'doughnut') return 'rgba(255,255,255,0.88)'; // ç™½è‰²è† å›Šï¼Œèˆ‡æ‰‡å½¢åˆ†é›¢
                    return 'rgba(51, 65, 85, 0.75)';
                },
                borderRadius: 6,
                padding: { top: 4, right: 6, bottom: 4, left: 6 },
                // è¼•å¾®æé‚Šï¼Œæå‡å°æ¯”
                textStrokeColor: (ctx) => {
                    const type = ctx.chart.config.type;
                    return (type === 'bar') ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.2)';
                },
                textStrokeWidth: 2,
                font: (ctx) => {
                    const type = ctx.chart.config.type;
                    return {
                        weight: '600',
                        size: (type === 'pie' || type === 'doughnut') ? 14 : 12,
                        family: 'Microsoft JhengHei, system-ui, -apple-system, Segoe UI, Roboto, Arial'
                    };
                },
                anchor: (ctx) => {
                    const type = ctx.chart.config.type;
                    if (type === 'bar') return 'end';
                    return 'center';
                },
                align: (ctx) => {
                    const type = ctx.chart.config.type;
                    if (type === 'bar') return 'end';
                    return 'center';
                },
                offset: (ctx) => {
                    const type = ctx.chart.config.type;
                    return (type === 'bar') ? 6 : 0;
                },
                clamp: true,
                clip: false,
                formatter: (value, ctx) => {
                    const type = ctx.chart.config.type;
                    if (type === 'pie' || type === 'doughnut') {
                        const data = ctx.chart.data.datasets[0]?.data || [];
                        const sum = data.reduce((a, b) => a + (typeof b === 'number' ? b : parseFloat(b) || 0), 0);
                        const pct = sum ? (value / sum * 100).toFixed(1) + '%' : '0%';
                        return `${value} (${pct})`;
                    }
                    return `${value}`;
                }
            };
        }
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            
            // å¦‚æœæœ‰ä¸Šå‚³çš„æª”æ¡ˆï¼Œè‡ªå‹•è®€å–
            if (window.fs && window.fs.readFile) {
                loadDemoData();
            }
            
            // ç›£è½è³‡æ–™ç­†æ•¸é¸æ“‡è®Šæ›´
            const rowsSelect = document.getElementById('rowsPerPage');
            if (rowsSelect) {
                // å¾ localStorage é‚„åŸé¸æ“‡
                const savedRows = localStorage.getItem('rowsPerPage');
                if (savedRows) {
                    rowsSelect.value = savedRows;
                }
                rowsSelect.addEventListener('change', function() {
                    localStorage.setItem('rowsPerPage', rowsSelect.value);
                    currentPage = 1;
                    updateDataTable();
                });
            }
            
            // åˆ†é æŒ‰éˆ•äº‹ä»¶
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');
            if (prevBtn && nextBtn) {
                prevBtn.addEventListener('click', function() {
                    currentPage = Math.max(1, currentPage - 1);
                    updateDataTable();
                });
                nextBtn.addEventListener('click', function() {
                    currentPage = currentPage + 1; // å¯¦éš›ä¸Šæœƒåœ¨ updateDataTable è£¡è¢«ä¸Šé™ä¿è­·
                    updateDataTable();
                });
            }
        });
        
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('content').style.display = 'none';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(firstSheet);
                
                processData();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
            };
            reader.readAsArrayBuffer(file);
        }
        
        function processData() {
            // æ›´æ–°çµ±è¨ˆå¡ç‰‡
            updateStatCards();
            
            // æ›´æ–°è·¯ç·šé¸é …
            updateRouteFilter();
            
            // åˆå§‹åŒ–åœ–è¡¨
            initCharts();
            
            // æ›´æ–°è³‡æ–™è¡¨
            updateDataTable();
        }
        
        function updateStatCards() {
            // ç¸½å•å·æ•¸
            document.getElementById('totalResponses').textContent = rawData.length;
            
            // è¨ˆç®—å¹³å‡æ»¿æ„åº¦
            const satisfactionMap = {
                'éå¸¸æ»¿æ„': 5,
                'æ»¿æ„': 4,
                'æ™®é€š': 3,
                'ä¸æ»¿æ„': 2,
                'éå¸¸ä¸æ»¿æ„': 1
            };
            
            let totalScore = 0;
            let validCount = 0;
            rawData.forEach(row => {
                const satisfaction = row['è«‹å•æ‚¨å°æ–¼ä»¥ä¸‹é …ç›®çš„æ»¿æ„åº¦ - (6)æ•´é«”æ»¿æ„åº¦'];
                if (satisfactionMap[satisfaction]) {
                    totalScore += satisfactionMap[satisfaction];
                    validCount++;
                }
            });
            
            const avgScore = validCount > 0 ? (totalScore / validCount / 5 * 100).toFixed(1) : 0;
            document.getElementById('avgSatisfaction').textContent = avgScore + '%';
            
            // APPä½¿ç”¨ç‡
            const appUsers = rawData.filter(row => row['æ‚¨æœ¬æ¬¡ä¹˜è»Šæ˜¯å¦æœ‰ä½¿ç”¨å®˜æ–¹ã€Œæ¡ƒåœ’å…¬è»Šã€APPï¼Ÿ'] === 'æœ‰ä½¿ç”¨').length;
            const appUsageRate = rawData.length > 0 ? ((appUsers / rawData.length) * 100).toFixed(1) : 0;
            document.getElementById('appUsageRate').textContent = appUsageRate + '%';
            
            // æ¯æ—¥æ­ä¹˜ç‡
            const dailyRiders = rawData.filter(row => row['æ‚¨æ­ä¹˜å…¬è»Šçš„é »ç‡'] === 'æ¯å¤©æ­ä¹˜').length;
            const dailyRate = rawData.length > 0 ? ((dailyRiders / rawData.length) * 100).toFixed(1) : 0;
            document.getElementById('dailyRidership').textContent = dailyRate + '%';
        }
        
        function updateRouteFilter() {
            const routes = [...new Set(rawData.map(row => row['æ‚¨æœ¬æ¬¡çš„æ­ä¹˜è·¯ç·š']).filter(r => r))];
            const select = document.getElementById('routeFilter');
            select.innerHTML = '<option value="all">æ‰€æœ‰è·¯ç·š</option>';
            routes.sort().forEach(route => {
                const option = document.createElement('option');
                option.value = route;
                option.textContent = route;
                select.appendChild(option);
            });
        }
        
        function initCharts() {
            // éŠ·æ¯€ç¾æœ‰åœ–è¡¨
            Object.values(charts).forEach(chart => {
                if (chart) chart.destroy();
            });
            
            // æ•´é«”æ»¿æ„åº¦åœ“é¤…åœ–
            const satisfactionCounts = {};
            rawData.forEach(row => {
                const satisfaction = row['è«‹å•æ‚¨å°æ–¼ä»¥ä¸‹é …ç›®çš„æ»¿æ„åº¦ - (6)æ•´é«”æ»¿æ„åº¦'];
                if (satisfaction) {
                    satisfactionCounts[satisfaction] = (satisfactionCounts[satisfaction] || 0) + 1;
                }
            });
            
            const ctx1 = document.getElementById('satisfactionChart').getContext('2d');
            charts.satisfaction = new Chart(ctx1, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(satisfactionCounts),
                    datasets: [{
                        data: Object.values(satisfactionCounts),
                        backgroundColor: [
                            '#4caf50',
                            '#8bc34a',
                            '#ffeb3b',
                            '#ff9800',
                            '#f44336'
                        ],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return label + ': ' + value + ' (' + percentage + '%)';
                                }
                            }
                        }
                    }
                }
            });
            
            // å¡«å¯«æ™‚æ©Ÿåˆ†æ
            const timingCounts = {};
            rawData.forEach(row => {
                const timing = row['è«‹å•æ‚¨åœ¨ä½•æ™‚å¡«å¯«æœ¬å•å·'];
                if (timing) {
                    timingCounts[timing] = (timingCounts[timing] || 0) + 1;
                }
            });
            
            const ctx2 = document.getElementById('timingChart').getContext('2d');
            charts.timing = new Chart(ctx2, {
                type: 'bar',
                data: {
                    labels: Object.keys(timingCounts),
                    datasets: [{
                        label: 'å•å·æ•¸é‡',
                        data: Object.values(timingCounts),
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
            
            // æ­ä¹˜ç›®çš„çµ±è¨ˆ
            const purposeCounts = {};
            rawData.forEach(row => {
                let purpose = row['æ‚¨æ­ä¹˜å…¬è»Šçš„ç›®çš„'];
                if (purpose) {
                    // ç°¡åŒ–å…¶ä»–é¡åˆ¥
                    if (purpose.startsWith('å…¶ä»–-')) {
                        purpose = 'å…¶ä»–';
                    }
                    purposeCounts[purpose] = (purposeCounts[purpose] || 0) + 1;
                }
            });
            
            // æ’åºä¸¦å–å‰10å€‹
            const sortedPurposes = Object.entries(purposeCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const ctx3 = document.getElementById('purposeChart').getContext('2d');
            charts.purpose = new Chart(ctx3, {
                type: 'bar',
                data: {
                    labels: sortedPurposes.map(p => p[0]),
                    datasets: [{
                        label: 'äººæ•¸',
                        data: sortedPurposes.map(p => p[1]),
                        backgroundColor: 'rgba(118, 75, 162, 0.8)',
                        borderColor: 'rgba(118, 75, 162, 1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    indexAxis: 'y',
                    plugins: {
                        // é‡å°æ©«å‘é•·æ¢æŒ‡å®šè³‡æ–™æ¨™ç±¤åœ¨æ£’å…§å³å´ï¼Œé¿å…è¶…å‡º
                        datalabels: {
                            anchor: 'end',
                            align: 'right',
                            offset: -4, // å¾€å…§ç¸®ï¼Œé¿å…è¶…å‡ºåœ–åŸŸ
                            clamp: true,
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            // é ç•™ 15% ç©ºé–“é¿å…è³‡æ–™æ¨™ç±¤æº¢å‡º
                            suggestedMax: (function(){
                                const max = Math.max(0, ...sortedPurposes.map(p=>p[1]));
                                return max ? Math.ceil(max * 1.15) : 5;
                            })()
                        }
                    }
                }
            });
            
            // å„é …æ»¿æ„åº¦æ¯”è¼ƒé›·é”åœ–
            const satisfactionItems = [
                '(1)é ä¼°åˆ°ç«™æ™‚é–“',
                '(2)å€™è»Šè¨­æ–½(ç«™ç‰Œã€åº§æ¤…)æƒ…å½¢',
                '(3)å€™è»Šç’°å¢ƒæ•´æ½”æƒ…å½¢',
                '(4)è»Šè¼›æ•´æ½”æƒ…å½¢',
                '(5)é§•é§›å“¡æœå‹™æ…‹åº¦',
                '(6)æ•´é«”æ»¿æ„åº¦'
            ];
            
            const satisfactionScores = satisfactionItems.map(item => {
                const fullKey = 'è«‹å•æ‚¨å°æ–¼ä»¥ä¸‹é …ç›®çš„æ»¿æ„åº¦ - ' + item;
                let totalScore = 0;
                let count = 0;
                
                const scoreMap = {
                    'éå¸¸æ»¿æ„': 5,
                    'æ»¿æ„': 4,
                    'æ™®é€š': 3,
                    'ä¸æ»¿æ„': 2,
                    'éå¸¸ä¸æ»¿æ„': 1
                };
                
                rawData.forEach(row => {
                    const value = row[fullKey];
                    if (scoreMap[value]) {
                        totalScore += scoreMap[value];
                        count++;
                    }
                });
                
                return count > 0 ? (totalScore / count).toFixed(2) : 0;
            });
            
            const ctx4 = document.getElementById('detailedSatisfactionChart').getContext('2d');
            charts.detailedSatisfaction = new Chart(ctx4, {
                type: 'radar',
                data: {
                    labels: satisfactionItems.map(item => item.replace(/\(\d\)/, '')),
                    datasets: [{
                        label: 'å¹³å‡æ»¿æ„åº¦åˆ†æ•¸',
                        data: satisfactionScores,
                        backgroundColor: 'rgba(102, 126, 234, 0.2)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2,
                        pointBackgroundColor: 'rgba(102, 126, 234, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(102, 126, 234, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 5,
                            pointLabels: {
                                color: '#333',
                                padding: 8,
                                font: {
                                    size: 16,
                                    weight: '600',
                                    family: 'Microsoft JhengHei, system-ui, -apple-system, Segoe UI, Roboto, Arial'
                                }
                            },
                            ticks: {
                                stepSize: 1,
                                backdropColor: 'transparent',
                                color: '#666',
                                font: {
                                    size: 12
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // å–å¾—ä¾ç•¶å‰æ¢ä»¶ç¯©é¸å¾Œçš„è³‡æ–™ï¼ˆè·¯ç·šã€æ—¥æœŸã€Œå¡«ç­”æ™‚é–“ã€ã€æ™‚æ®µï¼‰
        function getFilteredData() {
            const routeFilter = document.getElementById('routeFilter')?.value || 'all';
            const timeFilter = document.getElementById('timeFilter')?.value || 'all';
            const startDate = document.getElementById('startDate')?.value || '';
            const endDate = document.getElementById('endDate')?.value || '';

            let filteredData = [...rawData];

            // è·¯ç·šç¯©é¸
            if (routeFilter !== 'all') {
                filteredData = filteredData.filter(row => row['æ‚¨æœ¬æ¬¡çš„æ­ä¹˜è·¯ç·š'] === routeFilter);
            }

            // æ—¥æœŸç¯„åœï¼ˆä»¥ã€Œå¡«ç­”æ™‚é–“ã€æ¬„ä½ï¼‰
            if (startDate || endDate) {
                filteredData = filteredData.filter(row => {
                    const dateStr = row['å¡«ç­”æ™‚é–“'];
                    if (!dateStr) return true;
                    let rowDate;
                    try {
                        if (dateStr.includes('ä¸Šåˆ') || dateStr.includes('ä¸‹åˆ')) {
                            const datePart = dateStr.split(' ')[0];
                            const parts = datePart.split('/');
                            if (parts.length >= 3) {
                                rowDate = new Date(parts[0], parts[1] - 1, parts[2]);
                            }
                        } else if (dateStr.includes('/')) {
                            const parts = dateStr.split(' ')[0].split('/');
                            if (parts.length >= 3) {
                                rowDate = new Date(parts[0], parts[1] - 1, parts[2]);
                            }
                        } else if (dateStr.includes('-')) {
                            rowDate = new Date(dateStr.split(' ')[0]);
                        } else {
                            rowDate = new Date(dateStr);
                        }
                        if (isNaN(rowDate.getTime())) return true;
                        const rowDateStr = rowDate.toISOString().split('T')[0];
                        if (startDate && rowDateStr < startDate) return false;
                        if (endDate && rowDateStr > endDate) return false;
                        return true;
                    } catch {
                        return true;
                    }
                });
            }

            // æ™‚æ®µç¯©é¸ï¼ˆä¾æ­ä¹˜ç­æ¬¡æ™‚é–“ï¼‰
            if (timeFilter !== 'all') {
                filteredData = filteredData.filter(row => {
                    const time = row['æ‚¨æœ¬æ¬¡çš„æ­ä¹˜ç­æ¬¡'];
                    if (!time) return false;
                    const hourMatch = time.match(/(\d{1,2})[:ï¼š]/);
                    if (!hourMatch) return false;
                    const hour = parseInt(hourMatch[1]);
                    switch (timeFilter) {
                        case 'morning':
                            return hour >= 6 && hour < 12;
                        case 'afternoon':
                            return hour >= 12 && hour < 18;
                        case 'evening':
                            return hour >= 18 || hour < 6;
                        default:
                            return true;
                    }
                });
            }

            return filteredData;
        }

        function updateDataTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            // ä¾ç•¶å‰ç¯©é¸ + åˆ†é  é¡¯ç¤º
            const rowsValue = (document.getElementById('rowsPerPage') && document.getElementById('rowsPerPage').value) ? document.getElementById('rowsPerPage').value : '50';
            const sourceData = getFilteredData();
            const total = sourceData.length;
            const n = rowsValue === 'all' ? total : (parseInt(rowsValue, 10) || 50);
            const totalPages = n === 0 ? 1 : Math.max(1, Math.ceil(total / (rowsValue === 'all' ? total || 1 : n)));
            
            // ä¿®æ­£ currentPage é‚Šç•Œ
            if (currentPage > totalPages) currentPage = totalPages;
            if (currentPage < 1) currentPage = 1;
            
            const startIndex = rowsValue === 'all' ? 0 : (currentPage - 1) * n;
            const endIndex = rowsValue === 'all' ? total : Math.min(startIndex + n, total);
            const displayData = sourceData.slice(startIndex, endIndex);
            
            // æ›´æ–°è³‡è¨Šèˆ‡æŒ‰éˆ•ç‹€æ…‹
            const info = document.getElementById('tableInfo');
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');
            if (info) {
                const from = total === 0 ? 0 : (startIndex + 1);
                const to = endIndex;
                info.textContent = `é¡¯ç¤º ${from}â€“${to} / å…± ${total} ç­†`;
            }
            if (prevBtn && nextBtn) {
                if (rowsValue === 'all' || total <= n) {
                    prevBtn.disabled = true;
                    nextBtn.disabled = true;
                    prevBtn.style.opacity = '0.6';
                    nextBtn.style.opacity = '0.6';
                } else {
                    prevBtn.disabled = currentPage <= 1;
                    nextBtn.disabled = currentPage >= totalPages;
                    prevBtn.style.opacity = prevBtn.disabled ? '0.6' : '1';
                    nextBtn.style.opacity = nextBtn.disabled ? '0.6' : '1';
                }
            }
            
            displayData.forEach(row => {
                const tr = document.createElement('tr');
                
                const satisfaction = row['è«‹å•æ‚¨å°æ–¼ä»¥ä¸‹é …ç›®çš„æ»¿æ„åº¦ - (6)æ•´é«”æ»¿æ„åº¦'];
                let satisfactionClass = 'satisfaction-medium';
                if (satisfaction === 'éå¸¸æ»¿æ„' || satisfaction === 'æ»¿æ„') {
                    satisfactionClass = 'satisfaction-good';
                } else if (satisfaction === 'ä¸æ»¿æ„' || satisfaction === 'éå¸¸ä¸æ»¿æ„') {
                    satisfactionClass = 'satisfaction-bad';
                }
                
                tr.innerHTML = `
                    <td>${row['è«‹å•æ‚¨åœ¨ä½•æ™‚å¡«å¯«æœ¬å•å·'] || '-'}</td>
                    <td>${row['æ‚¨æœ¬æ¬¡æƒæQR CODEçš„ç«™ä½åç¨±'] || '-'}</td>
                    <td>${row['æ‚¨æœ¬æ¬¡çš„æ­ä¹˜è·¯ç·š'] || '-'}</td>
                    <td><span class="${satisfactionClass} satisfaction-indicator">${satisfaction || '-'}</span></td>
                    <td>${row['æ‚¨æ­ä¹˜å…¬è»Šçš„é »ç‡'] || '-'}</td>
                    <td>${row['æ‚¨æ­ä¹˜å…¬è»Šçš„ç›®çš„'] || '-'}</td>
                    <td>${row['å…¶ä»–å»ºè­°'] || '-'}</td>
                `;
                tbody.appendChild(tr);
            });
        }
        
        function updateCharts() {
            // è®Šæ›´ç¯©é¸æ™‚ï¼Œé‡ç½®åˆ°ç¬¬ä¸€é 
            currentPage = 1;
            // è¨˜éŒ„ç›®å‰æ¢ä»¶ï¼Œæ–¹ä¾¿é™¤éŒ¯
            const debug = {
                routeFilter: document.getElementById('routeFilter')?.value,
                timeFilter: document.getElementById('timeFilter')?.value,
                startDate: document.getElementById('startDate')?.value,
                endDate: document.getElementById('endDate')?.value,
            };
            console.log('ç¯©é¸æ¢ä»¶:', debug);
            if (rawData.length > 0) console.log('å¯ç”¨çš„æ¬„ä½åç¨±:', Object.keys(rawData[0]));

            const filteredData = getFilteredData();
            
            // æ›´æ–°åœ–è¡¨è³‡æ–™
            if (filteredData.length > 0) {
                // æ›´æ–°æ»¿æ„åº¦åœ–è¡¨
                const satisfactionCounts = {};
                filteredData.forEach(row => {
                    const satisfaction = row['è«‹å•æ‚¨å°æ–¼ä»¥ä¸‹é …ç›®çš„æ»¿æ„åº¦ - (6)æ•´é«”æ»¿æ„åº¦'];
                    if (satisfaction) {
                        satisfactionCounts[satisfaction] = (satisfactionCounts[satisfaction] || 0) + 1;
                    }
                });
                
                charts.satisfaction.data.labels = Object.keys(satisfactionCounts);
                charts.satisfaction.data.datasets[0].data = Object.values(satisfactionCounts);
                charts.satisfaction.update();
                
                // æ›´æ–°æ™‚æ©Ÿåœ–è¡¨
                const timingCounts = {};
                filteredData.forEach(row => {
                    const timing = row['è«‹å•æ‚¨åœ¨ä½•æ™‚å¡«å¯«æœ¬å•å·'];
                    if (timing) {
                        timingCounts[timing] = (timingCounts[timing] || 0) + 1;
                    }
                });
                
                charts.timing.data.labels = Object.keys(timingCounts);
                charts.timing.data.datasets[0].data = Object.values(timingCounts);
                charts.timing.update();
                
                // æ›´æ–°æ­ä¹˜ç›®çš„åœ–è¡¨ï¼ˆåˆä½µã€Œå…¶ä»–-ã€è‡³ã€Œå…¶ä»–ã€ï¼Œæ’åºå–å‰10ï¼‰
                const purposeCounts = {};
                filteredData.forEach(row => {
                    let purpose = row['æ‚¨æ­ä¹˜å…¬è»Šçš„ç›®çš„'];
                    if (purpose) {
                        if (typeof purpose === 'string' && purpose.startsWith('å…¶ä»–-')) {
                            purpose = 'å…¶ä»–';
                        }
                        purposeCounts[purpose] = (purposeCounts[purpose] || 0) + 1;
                    }
                });
                const sortedPurposes = Object.entries(purposeCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);
                charts.purpose.data.labels = sortedPurposes.map(p => p[0]);
                charts.purpose.data.datasets[0].data = sortedPurposes.map(p => p[1]);
                // å‹•æ…‹èª¿æ•´ X è»¸ä¸Šé™ï¼Œé¿å…è³‡æ–™æ¨™ç±¤è¶…å‡ºåœ–åŸŸ
                if (charts.purpose.options && charts.purpose.options.scales && charts.purpose.options.scales.x) {
                    const max = Math.max(0, ...sortedPurposes.map(p=>p[1]));
                    charts.purpose.options.scales.x.suggestedMax = max ? Math.ceil(max * 1.15) : 5;
                }
                charts.purpose.update();
                
                // æ›´æ–°å„é …æ»¿æ„åº¦æ¯”è¼ƒé›·é”åœ–ï¼ˆä»¥ç¯©é¸è³‡æ–™è¨ˆç®—å¹³å‡åˆ†æ•¸ï¼‰
                const satisfactionItems = [
                    '(1)é ä¼°åˆ°ç«™æ™‚é–“',
                    '(2)å€™è»Šè¨­æ–½(ç«™ç‰Œã€åº§æ¤…)æƒ…å½¢',
                    '(3)å€™è»Šç’°å¢ƒæ•´æ½”æƒ…å½¢',
                    '(4)è»Šè¼›æ•´æ½”æƒ…å½¢',
                    '(5)é§•é§›å“¡æœå‹™æ…‹åº¦',
                    '(6)æ•´é«”æ»¿æ„åº¦'
                ];
                const scoreMap = {
                    'éå¸¸æ»¿æ„': 5,
                    'æ»¿æ„': 4,
                    'æ™®é€š': 3,
                    'ä¸æ»¿æ„': 2,
                    'éå¸¸ä¸æ»¿æ„': 1
                };
                const filtScores = satisfactionItems.map(item => {
                    const key = 'è«‹å•æ‚¨å°æ–¼ä»¥ä¸‹é …ç›®çš„æ»¿æ„åº¦ - ' + item;
                    let sum = 0, cnt = 0;
                    filteredData.forEach(row => {
                        const v = row[key];
                        if (scoreMap[v]) { sum += scoreMap[v]; cnt++; }
                    });
                    return cnt > 0 ? (sum / cnt).toFixed(2) : 0;
                });
                charts.detailedSatisfaction.data.labels = satisfactionItems.map(item => item.replace(/\(\d\)/, ''));
                charts.detailedSatisfaction.data.datasets[0].data = filtScores;
                charts.detailedSatisfaction.update();
                
                alert(`å·²ç¯©é¸ ${filteredData.length} ç­†è³‡æ–™ä¸¦æ›´æ–°åœ–è¡¨`);
            } else {
                alert('ç¯©é¸æ¢ä»¶ç„¡ç¬¦åˆè³‡æ–™');
            }
            
            // åŒæ­¥æ›´æ–°è¡¨æ ¼é¡¯ç¤º
            updateDataTable();
        }
        
        async function exportReport() {
            try {
                if (!rawData || rawData.length === 0) {
                    alert('æ²’æœ‰å¯åŒ¯å‡ºçš„è³‡æ–™ï¼Œè«‹å…ˆä¸Šå‚³æˆ–è¼‰å…¥è³‡æ–™');
                    return;
                }

                const wb = XLSX.utils.book_new();
                const now = new Date();
                const ts = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;

                const filtered = getFilteredData();

                // æ¬„ä½éµå
                const KEY = {
                    route: 'æ‚¨æœ¬æ¬¡çš„æ­ä¹˜è·¯ç·š',
                    timing: 'è«‹å•æ‚¨åœ¨ä½•æ™‚å¡«å¯«æœ¬å•å·',
                    stop: 'æ‚¨æœ¬æ¬¡æƒæQR CODEçš„ç«™ä½åç¨±',
                    overallSat: 'è«‹å•æ‚¨å°æ–¼ä»¥ä¸‹é …ç›®çš„æ»¿æ„åº¦ - (6)æ•´é«”æ»¿æ„åº¦',
                    freq: 'æ‚¨æ­ä¹˜å…¬è»Šçš„é »ç‡',
                    purpose: 'æ‚¨æ­ä¹˜å…¬è»Šçš„ç›®çš„',
                    advice: 'å…¶ä»–å»ºè­°',
                    timeStr: 'æ­ä¹˜ç­æ¬¡',
                    filledAt: 'å¡«ç­”æ™‚é–“'
                };

                const scoreMap = { 'éå¸¸æ»¿æ„': 5, 'æ»¿æ„': 4, 'æ™®é€š': 3, 'ä¸æ»¿æ„': 2, 'éå¸¸ä¸æ»¿æ„': 1 };
                const satisfactionItems = [
                    '(1)å¸æ©Ÿæœå‹™æ…‹åº¦','(2)è¡Œè»Šå®‰å…¨èˆ‡èˆ’é©æ€§','(3)ç™¼è»Šæº–é»ç‡','(4)å€™è»Šè³‡è¨Šæä¾›','(5)ç¥¨åƒ¹èˆ‡è½‰ä¹˜','(6)æ•´é«”æ»¿æ„åº¦'
                ];

                const getAvgSat = (data) => {
                    let total=0, cnt=0; data.forEach(r=>{ const v=r[KEY.overallSat]; if (scoreMap[v]){ total+=scoreMap[v]; cnt++; }}); return cnt? (total/cnt): 0;
                };
                const percent = (a,b)=> b? (a/b*100).toFixed(1)+'%':'0%';
                const countBy = (data, key)=>{ const m={}; data.forEach(r=>{ const v=r[key]; if(v) m[v]=(m[v]||0)+1;}); return m; };
                const satAvgByRoute = (data)=>{
                    const m={}; data.forEach(r=>{ const route=r[KEY.route]; const v=r[KEY.overallSat]; if(!route||!scoreMap[v]) return; if(!m[route]) m[route]={sum:0,cnt:0}; m[route].sum+=scoreMap[v]; m[route].cnt++; }); return m; };
                const hourBucket = (r)=>{
                    // 1) å„ªå…ˆå¾ã€Œæ­ä¹˜ç­æ¬¡ã€æŠ“å°æ™‚
                    let text = r[KEY.timeStr];
                    let hour = null;
                    if (text && typeof text === 'string') {
                        const m = text.match(/(\d{1,2})[ï¼š:]/);
                        if (m) hour = parseInt(m[1]);
                    }
                    // 2) è‹¥æ²’æœ‰ï¼Œå˜—è©¦å¾ã€Œå¡«ç­”æ™‚é–“ã€è§£æ
                    if (hour === null) {
                        const ts = r[KEY.filledAt];
                        if (ts) {
                            const d = new Date(ts.replace(/\./g,'/').replace(/å¹´|æœˆ/g,'/').replace('æ—¥',''));
                            if (!isNaN(d.getTime())) hour = d.getHours();
                        }
                    }
                    if (hour === null || isNaN(hour)) return 'æœªå¡«';
                    if (hour>=6 && hour<12) return 'ä¸Šåˆ(06-12)';
                    if (hour>=12 && hour<18) return 'ä¸‹åˆ(12-18)';
                    return 'æ™šä¸Š(18-06)';
                };

                // 1) åŒ¯å‡ºè³‡è¨Šèˆ‡ç•¶å‰ç¯©é¸æ‘˜è¦
                const filterRoute = document.getElementById('routeFilter')?.value || 'all';
                const filterTime = document.getElementById('timeFilter')?.value || 'all';
                const startDate = document.getElementById('startDate')?.value || '';
                const endDate = document.getElementById('endDate')?.value || '';

                const summaryAOA = [
                    ['æ¡ƒåœ’å¸‚å…¬è»Šä¹˜å®¢æ»¿æ„åº¦ - åŒ¯å‡ºæ‘˜è¦'],
                    ['åŒ¯å‡ºæ™‚é–“', ts],
                    [],
                    ['ç›®å‰ç¯©é¸æ¢ä»¶'],
                    ['è·¯ç·š', filterRoute],
                    ['æ™‚æ®µ', filterTime],
                    ['æ—¥æœŸç¯„åœ', startDate && endDate ? `${startDate} ~ ${endDate}` : (startDate||endDate||'æœªæŒ‡å®š')],
                    [],
                    ['æ•´é«”æ¦‚è¦½ (å…¨éƒ¨è³‡æ–™)'],
                    ['ç¸½å•å·æ•¸', rawData.length],
                    ['å¹³å‡æ•´é«”æ»¿æ„åº¦(1-5)', getAvgSat(rawData).toFixed(2)],
                    ['APPä½¿ç”¨ç‡', percent(rawData.filter(r=>r['æ‚¨æœ¬æ¬¡ä¹˜è»Šæ˜¯å¦æœ‰ä½¿ç”¨å®˜æ–¹ã€Œæ¡ƒåœ’å…¬è»Šã€APPï¼Ÿ']==='æœ‰ä½¿ç”¨').length, rawData.length)],
                    ['æ¯æ—¥æ­ä¹˜ç‡', percent(rawData.filter(r=>r[KEY.freq]==='æ¯å¤©æ­ä¹˜').length, rawData.length)],
                    [],
                    ['ç›®å‰ç¯©é¸å¾Œæ¦‚è¦½'],
                    ['ç¸½å•å·æ•¸', filtered.length],
                    ['å¹³å‡æ•´é«”æ»¿æ„åº¦(1-5)', getAvgSat(filtered).toFixed(2)],
                    ['APPä½¿ç”¨ç‡', percent(filtered.filter(r=>r['æ‚¨æœ¬æ¬¡ä¹˜è»Šæ˜¯å¦æœ‰ä½¿ç”¨å®˜æ–¹ã€Œæ¡ƒåœ’å…¬è»Šã€APPï¼Ÿ']==='æœ‰ä½¿ç”¨').length, filtered.length)],
                    ['æ¯æ—¥æ­ä¹˜ç‡', percent(filtered.filter(r=>r[KEY.freq]==='æ¯å¤©æ­ä¹˜').length, filtered.length)],
                ];
                XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(summaryAOA), 'åŒ¯å‡ºæ‘˜è¦');

                // 2) æ»¿æ„åº¦åˆ†å¸ƒ (å…¨éƒ¨/ç¯©é¸)
                const satAll = countBy(rawData, KEY.overallSat);
                const satFilt = countBy(filtered, KEY.overallSat);
                const satRows = [['æ•´é«”æ»¿æ„åº¦','å…¨éƒ¨æ•¸é‡','ç¯©é¸å¾Œæ•¸é‡','å…¨éƒ¨å æ¯”','ç¯©é¸å æ¯”']];
                const allTotal = rawData.length || 1; const filtTotal = filtered.length || 1;
                const allKeys = Array.from(new Set([...Object.keys(satAll), ...Object.keys(satFilt)]));
                allKeys.forEach(k=>{
                    const a = satAll[k]||0, f=satFilt[k]||0;
                    satRows.push([k, a, f, percent(a, allTotal), percent(f, filtTotal)]);
                });
                XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(satRows), 'æ•´é«”æ»¿æ„åº¦åˆ†å¸ƒ');

                // 3) å„é …æ»¿æ„åº¦å¹³å‡ (å…¨éƒ¨/ç¯©é¸)
                const detailRows = [['é …ç›®','å…¨éƒ¨å¹³å‡(1-5)','ç¯©é¸å¹³å‡(1-5)','å…¨éƒ¨æ¨£æœ¬æ•¸','ç¯©é¸æ¨£æœ¬æ•¸']];
                satisfactionItems.forEach(item=>{
                    const key = 'è«‹å•æ‚¨å°æ–¼ä»¥ä¸‹é …ç›®çš„æ»¿æ„åº¦ - ' + item;
                    let s1=0,c1=0; rawData.forEach(r=>{ const v=r[key]; if(scoreMap[v]){ s1+=scoreMap[v]; c1++; }});
                    let s2=0,c2=0; filtered.forEach(r=>{ const v=r[key]; if(scoreMap[v]){ s2+=scoreMap[v]; c2++; }});
                    detailRows.push([item, c1? (s1/c1).toFixed(2):'0.00', c2? (s2/c2).toFixed(2):'0.00', c1, c2]);
                });
                XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(detailRows), 'å„é …æ»¿æ„åº¦å¹³å‡');

                // 4) è·¯ç·šåˆ†æ (ç¯©é¸å¾Œ)
                const routeCounts = countBy(filtered, KEY.route);
                const routeSat = satAvgByRoute(filtered);
                const routeRows = [['è·¯ç·š','ç­†æ•¸','å¹³å‡æ•´é«”æ»¿æ„åº¦(1-5)']];
                Object.keys(routeCounts).sort().forEach(route=>{
                    const info = routeSat[route] || {sum:0,cnt:0};
                    const avg = info.cnt? (info.sum/info.cnt).toFixed(2):'0.00';
                    routeRows.push([route, routeCounts[route], avg]);
                });
                XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(routeRows), 'è·¯ç·šåˆ†æ(ç¯©é¸)');

                // 5) æ™‚æ®µåˆ†æ (ä¾æ­ä¹˜ç­æ¬¡è½‰æ¡¶)
                const bucketAll = {}; rawData.forEach(r=>{ const b=hourBucket(r); bucketAll[b]=(bucketAll[b]||0)+1;});
                const bucketFil = {}; filtered.forEach(r=>{ const b=hourBucket(r); bucketFil[b]=(bucketFil[b]||0)+1;});
                const timeRows = [['æ™‚æ®µæ¡¶','å…¨éƒ¨æ•¸é‡','ç¯©é¸å¾Œæ•¸é‡','å…¨éƒ¨å æ¯”','ç¯©é¸å æ¯”']];
                const fixedBuckets = ['ä¸Šåˆ(06-12)','ä¸‹åˆ(12-18)','æ™šä¸Š(18-06)','æœªå¡«'];
                fixedBuckets.forEach(k=>{
                    const a=bucketAll[k]||0, f=bucketFil[k]||0;
                    timeRows.push([k, a, f, percent(a, allTotal), percent(f, filtTotal)]);
                });
                XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(timeRows), 'æ™‚æ®µåˆ†æ');

                // 6) å…¶ä»–åˆ†å¸ƒï¼šå¡«å¯«æ™‚æ©Ÿ / æ­ä¹˜é »ç‡ / æ­ä¹˜ç›®çš„ (å…¨éƒ¨/ç¯©é¸)
                const buildDistSheet = (title, key)=>{
                    const aAll=countBy(rawData,key), aFil=countBy(filtered,key);
                    const header=[[title],['é¸é …','å…¨éƒ¨æ•¸é‡','ç¯©é¸å¾Œæ•¸é‡','å…¨éƒ¨å æ¯”','ç¯©é¸å æ¯”']];
                    const keys=Array.from(new Set([...Object.keys(aAll),...Object.keys(aFil)]));
                    const rows=[]; keys.forEach(k=>{ const a=aAll[k]||0,f=aFil[k]||0; rows.push([k,a,f,percent(a,allTotal),percent(f,filtTotal)]); });
                    const ws=XLSX.utils.aoa_to_sheet([...header, ...rows]);
                    XLSX.utils.book_append_sheet(wb, ws, title);
                };
                buildDistSheet('å¡«å¯«æ™‚æ©Ÿåˆ†å¸ƒ', KEY.timing);
                buildDistSheet('æ­ä¹˜é »ç‡åˆ†å¸ƒ', KEY.freq);
                buildDistSheet('æ­ä¹˜ç›®çš„åˆ†å¸ƒ', KEY.purpose);

                // 7) ç›®å‰ç¯©é¸è³‡æ–™ & å…¨éƒ¨åŸå§‹è³‡æ–™
                const wsFiltered = XLSX.utils.json_to_sheet(filtered);
                XLSX.utils.book_append_sheet(wb, wsFiltered, 'ç›®å‰ç¯©é¸è³‡æ–™');
                const wsAll = XLSX.utils.json_to_sheet(rawData);
                XLSX.utils.book_append_sheet(wb, wsAll, 'åŸå§‹è³‡æ–™(å…¨éƒ¨)');

                // å¯«æª”
                const fileName = `æ¡ƒåœ’å¸‚å…¬è»Šæ»¿æ„åº¦_åˆ†æå ±å‘Š_${now.toISOString().replace(/[:T]/g,'-').split('.')[0]}.xlsx`;
                XLSX.writeFile(wb, fileName);
                alert('Excel å ±å‘Šå·²åŒ¯å‡ºå®Œæˆ');
            } catch (e) {
                console.error('Excel åŒ¯å‡ºå¤±æ•—:', e);
                alert('Excel åŒ¯å‡ºå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
            }
        }
        
        async function loadDemoData() {
            try {
                document.getElementById('loading').style.display = 'block';
                
                // å˜—è©¦è®€å–ä¸Šå‚³çš„æª”æ¡ˆ
                const response = await window.fs.readFile('STANDARD_nOyK1_æ¡ƒåœ’å¸‚è½„å¸‚å€å…¬è»Šä¹˜å®¢æ»¿æ„åº¦å•å·èª¿æŸ¥_202508190304_68a3e9c863b07.xlsx');
                const workbook = XLSX.read(response, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                rawData = XLSX.utils.sheet_to_json(firstSheet);
                
                processData();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
            } catch (error) {
                console.log('è«‹æ‰‹å‹•ä¸Šå‚³æª”æ¡ˆ');
                document.getElementById('loading').style.display = 'none';
            }
        }
    </script>
</body>
</html>